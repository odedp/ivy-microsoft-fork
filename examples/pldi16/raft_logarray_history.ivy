#lang ivy1.3
# James Wilcox & Oded Padon 2016
#
# A model of the Raft consensus protocol from Ongaro and Ousterhout.
#
#
# See [the paper](https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf)
# or [the dissertation](https://ramcloud.stanford.edu/~ongaro/raftproof.pdf)
# for more details about Raft.


################################################################################
#
# Module for axiomatizing a totally ordered set with fixed order
#
# The module includes an le relation, a minimal element (zero) and
# get_succ and get_pred actions.
#
# In this module, the order is arbitrary and fixed.
#
################################################################################

module total_order(carrier) = {
    relation le(X:carrier,Y:carrier)   # less than or equal

    axiom le(X, X)                        # Reflexivity
    axiom le(X, Y) & le(Y, Z) -> le(X, Z) # Transitivity
    axiom le(X, Y) & le(Y, X) -> X = Y    # Anti-symmetry
    axiom le(X, Y) | le(Y, X)             # Totality

    individual zero:carrier
    axiom le(zero, X)

    action get_succ(x:carrier) returns (y:carrier) = {
       assume le(x,y) & x ~= y & ((le(x, Z) & x ~= Z) -> le(y, Z))
    }

    action get_pred(y:carrier) returns (x:carrier) = {
       assume le(x,y) & x ~= y & ((le(x, Z) & x ~= Z) -> le(y, Z))
    }
}


################################################################################
#
# A module for messages, with message reordering and duplication#
#
# To be consistent with message cardinality abstraction, use tuple
# (extensional) types for messages
#
################################################################################

module msg(m_t) = {
    relation pending(M: m_t, N: node)
    init ~pending(M, N)
    individual source(M: m_t): node

    action receive(n: node) returns (m: m_t) = {
        assume pending(m, n);
        # pending(m, n) := * # to abstract message cardinality (which allows duplicates)
        # for easier find of the inductive invariant, we remove from pending, later we will comment this out
        pending(m, n) := false # to abstract message cardinality (which allows duplicates)

    }
}


################################################################################
#
# Types, relations and functions describing state of the network
#
################################################################################

# a nullary predicate switch for a fresh start (everyone at term zero,
# all followers), from a start where the leader election invariant is
# satsified and the logs are empty, but nodes can be in all states and
# all terms
#relation fresh_start
# init fresh_start

type node

# Each node is either a leader, follower, or candidate.
relation leader(N:node)
relation follower(N:node)
relation candidate(N:node)
conjecture leader(N) | follower(N) | candidate(N)
conjecture ~(leader(N) & follower(N))
conjecture ~(leader(N) & candidate(N))
conjecture ~(follower(N) & candidate(N))
# init ~leader(N)
# init follower(N)
# init ~candidate(N)

# In Raft, a term is a non-negative integer. But it is sufficient to
# model terms as a total order with an initial element.
type term
instantiate term : total_order(term)

# In Raft, indices are non-negative integers, but we model them as a
# totally ordered set.
type index
instantiate index : total_order(index)

# Each node has a current term, initially zero.  We model this by a
# partial function, as a real function breaks stratification and is
# not requires for the proof
relation current_term_of_node(N: node, T: term)
# init current_term_of_node(N, T) <-> T = term.zero
conjecture current_term_of_node(N, T1) & current_term_of_node(N, T2) -> T1 = T2

# The following two message types represent the request and reply to a
# RequestVote RPC.


# request vote messages
type request_vote_t
instantiate request_vote : msg(request_vote_t)
# message fields:
individual request_vote_term(M:request_vote_t) : term
individual request_vote_last_log_index(M:request_vote_t): index
individual request_vote_last_log_term(M:request_vote_t): term
# extensionality axiom - request_vote_t is a tuple
axiom (
    request_vote.source(M1) = request_vote.source(M2) &
    request_vote_term(M1) = request_vote_term(M2) &
    request_vote_last_log_index(M1) = request_vote_last_log_index(M2) &
    request_vote_last_log_term(M1) = request_vote_last_log_term(M2)
) -> M1 = M2


# request vote reply messages
type request_vote_reply_t
instantiate request_vote_reply : msg(request_vote_reply_t)
# message fields:
individual request_vote_reply_term(M:request_vote_reply_t) : term
# extensionality axiom - request_vote_reply_t is a tuple
axiom (
    request_vote_reply.source(M1) = request_vote_reply.source(M2) &
    request_vote_reply_term(M1) = request_vote_reply_term(M2)
) -> M1 = M2


# The votedFor  field from the paper.
# In practice, this information is only kept for the current term,
# but it is useful for verification to keep the entire history.
relation voted_for(T: term, VOTER: node, CANDIDATE: node)
# init ~voted_for(T, V, C)
# this is an intended partial function
conjecture voted_for(T,N,N1) & voted_for(T,N,N2) -> N1 = N2

# When a candidate receives a vote from another node, it records it here.
# In practive, this would be kept only for the current term.
relation received_votes(T: term, CANDIDATE:node, VOTER: node)
# init ~received_votes(T, C, V)

# A type representing a quorum of nodes; see concensus_quorum.ivy for
# another example of how this can be used.
type quorum
relation member(N:node, Q:quorum)
# Every two quorums has at least one node in their intersection,
# witnessed by the following function:
individual quorum_intersection(Q1:quorum, Q2:quorum) : node
# The function has to actually pick out a node that is a member of
# each quorum.
axiom member(quorum_intersection(Q1, Q2), Q1)
axiom member(quorum_intersection(Q1, Q2), Q2)
# This seems reasonable from a practical perspective, but it's not
# actually needed.
#   axiom exists Q:quorum. member(N, Q)
# Note that this axiom will immediately break stratification

# For the purposes of verification, it is useful to remember which
# quorum was responsible for electing the leader in each term.
# This would not be used in practice.
# Note: this replaces a forall exists in the invariant
# Note: we do not parametrise this by the node, as this would break stratification
individual quorum_of_election(T: term): quorum


# Servers log
# Each log entry contains
#   * a client command to execute
#   * the term of the leader that received the command from the client
#
# In practice, entries contain information such as the id of the
# client that sent the request etc. All of this is represented by the
# command element here.
#
# For verification, we keep the log as a partial function from
# node,term to log_entry, where log_entry is a tuple of term,command
#
# The log is modeled as partial functions from node,index to commands and terms
# note that the first log entry goes at index one and not zero

# A request from an external client.
type command

relation log_command(N:node, I:index, C:command)
relation log_term(N:node, I:index, T:term)
# assume that initially there is a common command in all logs, at index zero and term zero
individual first_command : command
init log_command(N, I, C) <-> I = index.zero & C = first_command
init log_term(N, I, T) <-> I = index.zero & T = term.zero
conjecture log_command(N, index.zero, first_command)
conjecture log_term(N, index.zero, term.zero)
conjecture log_command(N, I, C1) & log_command(N, I, C2) -> C1 = C2
conjecture log_term(N, I, T1) & log_term(N, I, T2) -> T1 = T2

# We have to keep the last used log index in a function (and not
# recover it from log_command and log_term). Otherwise a candidate
# might send a request_to_vote, and then forget all of its log.
#
# individual last_log_index(N:node) : index
#
# Maybe we don't need this, since forgetting something from the log
# requires dropping a command or a term, which means that all nodes
# will "forget" the same entry together. I'll try without it for now.

action get_last_log_entry_of_node(n:node) returns (i:index) = {
    # return the last index from n's log (note that we assume the log isn't empty, which is ok due to first_command).
    local t:term {
        assume log_term(n, i, t)
    };
    assume (log_term(n, I, T) | log_command(n, I, C)) -> index.le(I, i)
}

# Each node stores the index of highest log entry known to be
# comitted, initially zero
#
# This must be a partial function to preserve function stratification
# (see raft_logarray_matching_loops.ivy) for an example that has
# matching loops when this is a real function
#
relation commit_index(N:node, I:index)
init commit_index(N, I) <-> I = index.zero
conjecture commit_index(N, I1) & commit_index(N, I2) -> I1 = I2

# As with leader election, it is useful to remember the quorum used to
# commit an entry. Again, note that we do not parameterize this by the
# node.
individual quorum_of_commit(I:index) : quorum

# Leaders store for each server, the index of the highest log entry
# known to be replicated on the server. Note that index refers to
# index in the leader's log. This is reinialized to zero after every election.
#
# The natural way to model this is a function:
#
# individual match_index(L:node, N:node) : index
#
# Making this a function breaks stratification, (see
# raft_logarray_matching_loops_another.ivy) and a partial function
# loses the universal invariant, due to the precondition of the commit
# action.
#
# Thus, I model the predicate matches which is defined by:
#
# matches(L, N, I) = I <= match_index(L, N)
#
relation matches(L:node, N:node, I:index)
init matches(L, N, I) <-> I = index.zero
# as per its definition, matches(L,N,.) is downward closed:
conjecture index.le(I1, I2) & matches(L, N, I2) -> matches(L, N, I1)

# The following two types represent the request and reply messages for
# the AppendEntries RPC.  For simplicity, this model only allows one
# entry to be sent in each AppendEntries RPC.

# append entry messages (called simply append here)
type append_t
instantiate append : msg(append_t)
# message fields:
individual append_leader_term(M:append_t) : term
individual append_prev_log_index(M:append_t): index
individual append_prev_log_term(M:append_t): term
individual append_new_log_index(M:append_t): index
individual append_new_command(M:append_t): command
individual append_new_term(M:append_t): term
individual append_leader_commit_index(M:append_t): index
# extensionality axiom - append_t is a tuple
axiom (
    append.source(M1) = append.source(M2) &
    append_leader_term(M1) = append_leader_term(M2) &
    append_prev_log_index(M1) = append_prev_log_index(M2) &
    append_prev_log_term(M1) = append_prev_log_term(M2) &
    append_new_log_index(M1) = append_new_log_index(M2) &
    append_new_command(M1) = append_new_command(M2) &
    append_new_term(M1) = append_new_term(M2) &
    append_leader_commit_index(M1) = append_leader_commit_index(M2)
) -> M1 = M2

# Note that append_new_log_index is just manual quantifier
# instantiation. The protocol doesn't need it, and receive_append
# doesn't look at it. The following conjecture states that it's always
# just the successor of append_prev_log_index
conjecture append.pending(M, N) -> (
    index.le(append_prev_log_index(M), append_new_log_index(M)) &
    append_prev_log_index(M) ~= append_new_log_index(M) &
    (
        (index.le(append_prev_log_index(M), Z) &
         append_prev_log_index(M) ~= Z
     ) -> index.le(append_new_log_index(M), Z)
    )
)

# append entry reply messages (called append_reply here)
#
# an append reply means is sent after a successful append to the log,
# with the index of the new appended command. Note that we don't
# include the term in the reply, but I think it's still correct. Also
# note that it's important for the invariant that we keep the index of
# the new command, and not just copy the prev_log_index from the
# append message, as otherwise the invariant will have to mention
# successive indices (the invariant will have to say that if you sent
# an append_reply with index i, then your i+1 entry is in sync, which
# is actually forall exists).
#
type append_reply_t
instantiate append_reply : msg(append_reply_t)
# message fields:
individual append_reply_new_log_index(M:append_reply_t): index
# extensionality axiom - append_reply_t is a tuple
axiom (
    append_reply.source(M1) = append_reply.source(M2) &
    append_reply_new_log_index(M1) = append_reply_new_log_index(M2)
) -> M1 = M2


# General note about reply messages (both request_vote and append):
# failed messages are just not sent, and the term used for the
# candidate/leader to update itself is abstracted away, and replaced
# by the action jump_to_higher_term

# An error flag used to specify the safety property that we should
# never remove committed log entries
relation removed_committed(N:node)
init ~removed_committed(N)




# following raft_logarray_interesting_cti.ivy, we need instrumentation
# to record if a term higher then t was ever at the log index i at
# node n. this is a bit similar to the conversion from match_index to
# matches, but as instrumentation and not as a replatement
relation log_term_was_ge(N:node, I:index, T:term)
init log_term_was_ge(N, I, T) <->  I = index.zero & T = term.zero
# conjectures that come from the definition of log_term_was_ge
conjecture log_term(N, I, T) -> log_term_was_ge(N, I, T)
conjecture term.le(T1, T2) & log_term_was_ge(N, I, T2) -> log_term_was_ge(N, I, T1) # downward closed

# following another CTI, I realize that it may make sense to keep the
# entire history if the log of each server, i.e. to make
# log_term(node, term, index, term). This is needed to say something
# that relates pending append messages to the log of their
# source. However, this would make visualizations harder. Instead, I
# will try to rely on the log matching property, and define an
# instrumentation that existentially projects all nodes and all
# history - biglog. Here it is:
relation biglog(I:index, T:term, C:command)
init biglog(I, T, C) <-> I = index.zero & T = term.zero & C = first_command
# from the definition of biglog:
conjecture log_term(N, I, T) & log_command(N, I, C) -> biglog(I, T, C)

# following another CTI, I add committed(I,T,C) which means (I,T,C) was comitted somewhere sometime
relation committed(I:index, T:term, C:command)
init committed(I, T, C) <-> I = index.zero & T = term.zero & C = first_command
# from definition of committed
conjecture commit_index(N, CI) & index.le(I, CI) & log_term(N, I, T) & log_command(N, I, C) -> committed(I, T, C)


################################################################################
#
# Protocol actions for leader election
#
################################################################################

action start_election = {
    # Nondeterministic event to go to the next term and try to become
    # leader. In practice, this would be triggered by a timeout.

    local n:node, current_term: term, next_term:term, m:request_vote_t, log_i:index, log_t:term {
        # only a follower or a candidate start a new election
        assume ~leader(n);

        # increase current term
        assume current_term_of_node(n, current_term);
        next_term := term.get_succ(current_term);
        current_term_of_node(n, T) := T = next_term;

        # become candidate
        candidate(n) := true;
        follower(n) := false;
        leader(n) := false;

        # send a request_vote message
        #
        # note that a tuple type is "immutable", so we assume instead
        # of assign to create a tuple
        #
        assume request_vote.source(m) = n;
        assume request_vote_term(m) = next_term;
        # log_i, log_t should be the last index and term in n's log,
        # but it suffices just to assume that they are in n's log, not
        # necessarily from the last entry
        log_i := get_last_log_entry_of_node(n);
        assume log_term(n, log_i, log_t);
        assume request_vote_last_log_index(m) = log_i;
        assume request_vote_last_log_term(m) = log_t;
        # send the message to everyone
        request_vote.pending(m, N) := true;

        # vote for self and initialize received_votes
        voted_for(next_term, n, N) := N = n;
        received_votes(next_term, n, N) := N = n
    }
}

action jump_to_higher_term = {
    # Any node can nondeterministically become a follower with a
    # higher term. This models receiving an RPC request or response
    # with a higher term.
    #
    # We also use this action to model a candidate becoming a follower
    # of the same term, as if it got an AppendEntry RPC
    local n:node, current_term: term, new_term:term {
        assume current_term_of_node(n, current_term);
        assume (
            # moving from any state to a follower of a strictly higher term
            (term.le(current_term, new_term) & current_term ~= new_term) |
            # moving from a candidate of term t to a follower of term t
            (candidate(n) & new_term = current_term)
        );
        current_term_of_node(n, T) := T = new_term;
        candidate(n) := false;
        follower(n) := true;
        leader(n) := false
    }
}

action receive_request_vote = {
    # receive a request_vote message. Due to jump_to_higher_term, we
    # only need to handle the case that the recieving node is a
    # follower, and the receiving node's term exactly matches the term
    # in the request. Note that this increases the number of protocol
    # steps needed to make progress, which may not be a good thing
    # (but on the other hand this simplifies each step).
    #
    # Note that since we only need to send a successful reply, we can
    # ignore requests that will not succeed. Thus, many things that
    # are "if" in the implementation become "assume" here
    local n:node, current_term:term, m:request_vote_t, i1:index, i2:index, t1:term, t2:term, r:request_vote_reply_t {
        assume follower(n);
        assume current_term_of_node(n, current_term);
        m := request_vote.receive(n);
        assume current_term = request_vote_term(m);

        # assume we haven't voted for anyone in this term
        assume ~voted_for(current_term, n, C:node);

        # assume the log of the candidate is at least as "up-to-date"
        # as n's log (see section 5.4.1 in the paper)
        i1 := get_last_log_entry_of_node(n);
        assume log_term(n, i1, t1);
        i2 := request_vote_last_log_index(m);
        t2 := request_vote_last_log_term(m);
        # assume (t1, i1) <= (t2, i2) lexicographically
        assume (t1 ~= t2 & term.le(t1, t2)) | (t1 = t2 & index.le(i1, i2));

        # vote for source of m
        voted_for(current_term, n, request_vote.source(m)) := true;
        # send request_vote_reply
        assume request_vote_reply.source(r) = n;
        assume request_vote_reply_term(r) = request_vote_term(m);
        request_vote_reply.pending(r, request_vote.source(m)) := true
    }
}

action receive_request_vote_reply = {
    local n:node, current_term:term, m:request_vote_reply_t {
        assume candidate(n);
        assume current_term_of_node(n, current_term);
        m := request_vote_reply.receive(n);
        assume current_term = request_vote_reply_term(m);
        received_votes(request_vote_reply_term(m), n, request_vote_reply.source(m)) := true
    }
}

action become_leader = {
    # Nondeterministically become leader if received votes from a
    # quorum. In practice this would be checked for when processing a
    # RequestVote reply.
    local n:node, current_term:term, q:quorum {
        assume candidate(n);
        assume current_term_of_node(n, current_term);
        assume member(V, q) -> received_votes(current_term, n, V);
        quorum_of_election(current_term) := q;
        candidate(n) := false;
        follower(n) := false;
        leader(n) := true;
        matches(n, N, I) := I = index.zero
    }
}

# export leader election actions

export start_election
export jump_to_higher_term
export receive_request_vote
export receive_request_vote_reply
export become_leader

# initial state after leader election but no log replication

init leader(N) | follower(N) | candidate(N)
init ~(leader(N) & follower(N))
init ~(leader(N) & candidate(N))
init ~(follower(N) & candidate(N))
init current_term_of_node(N, T1) & current_term_of_node(N, T2) -> T1 = T2
init voted_for(T,N,N1) & voted_for(T,N,N2) -> N1 = N2
init leader(N1) & leader(N2) & current_term_of_node(N1, T) & current_term_of_node(N2, T) -> N1 = N2
init ~(request_vote_reply.pending(R,N) & ~voted_for(request_vote_reply_term(R),request_vote_reply.source(R),N))
init ~(current_term_of_node(L,T) & member(V,quorum_of_election(T)) & leader(L) & ~received_votes(T,L,V))
init ~(received_votes(T,N,V) & ~voted_for(T,V,N))
init ~(current_term_of_node(V, CT) & term.le(CT,T) & voted_for(T,V,N) & CT ~= T)

################################################################################
#
# Protocol actions for log replication
#
################################################################################

action client_request = {
    # leader receives a request from the outside world, and appends it
    # to its log
    local l:node, current_term:term, c:command, last_i:index, new_i:index {
        assume leader(l);
        assume current_term_of_node(l, current_term);

        # maybe we can assume c is not in the log of any server, but I don't think we need it

        # compute the index where the new command goes
        last_i := get_last_log_entry_of_node(l);
        new_i := index.get_succ(last_i);

        # insert the new command at the current term at index new_i
        log_command(l, new_i, C) := C = c;
        log_term(l, new_i, T) := T = current_term;
        log_term_was_ge(l, new_i, T) := log_term_was_ge(l, new_i, T) | term.le(T, current_term);
        biglog(new_i, current_term, c) := true;

        # increase match_index(l, l)
        matches(l, l, I) := index.le(I,new_i)
    }
}

action send_append = {
    # leader sends an AppendEntry RPC. We abstract nextIndex of the
    # paper by letting the leader send any log entry to any node.
    local l:node, n:node, current_term:term, ci:index, prev_i:index, i:index, prev_t:term, t:term, c:command, m:append_t {
        assume leader(l);
        assume current_term_of_node(l, current_term);
        assume commit_index(l, ci);

        # get information about two successive entries from l's log
        i := index.get_succ(prev_i); # note that this forces i > zero
        assume log_term(l, prev_i, prev_t);
        assume log_term(l, i, t);
        assume log_command(l, i, c);

        # prepare the append message (using assumes as append_t is a tuple)
        assume append.source(m) = l;
        assume append_leader_term(m) = current_term;
        assume append_prev_log_index(m) = prev_i;
        assume append_prev_log_term(m) = prev_t;
        assume append_new_log_index(m) = i;
        assume append_new_command(m) = c;
        assume append_new_term(m) = t;
        assume append_leader_commit_index(m) = ci;

        # send the message to node n
        append.pending(m, n) := true
    }
}

action receive_append = {
    # node receives an AppendEntry RPC. Due to jump_to_higher_term
    # (and failures as no reply), we can ignore all messages with
    # leader_term ~= current_term.
    local n:node, current_term:term, ci:index, m:append_t, i:index, r:append_reply_t {
        assume follower(n);
        assume current_term_of_node(n, current_term);
        assume commit_index(n, ci);
        m := append.receive(n);
        assume current_term = append_leader_term(m);

        # Due to failures as no reply, we can assume that
        # prev_log_index and prev_log_term agree with n's log
        assume log_term(n, append_prev_log_index(m), append_prev_log_term(m));

        # compute the index of the new command
        i := index.get_succ(append_prev_log_index(m));

        # check if we don't already have the new command
        if ~log_term(n, i, append_new_term(m)) {
            # we don't have the new command, or we have a conflicting
            # command. remove all entries starting at i, and insert the new command

            # check if we are about to remove committed entries, if so, turn on the error flag
            if index.le(i, ci) {
                removed_committed(n) := true
            };

            # remove entries at I >= i
            log_term(n, I, T) := log_term(n, I, T) & ~index.le(i, I);
            log_command(n, I, C) := log_command(n, I, C) & ~index.le(i, I); # not really necessary, but why not clean up

            # put new command at i
            log_term(n, i, T) := T = append_new_term(m);
            log_command(n, i, C) := C = append_new_command(m);
            log_term_was_ge(n, i, T) := log_term_was_ge(n, i, T) | term.le(T, append_new_term(m));
            biglog(i, append_new_term(m), append_new_command(m)) := true
        };

        # if leader_commit_index > commit_index, set commit_index = min(leader_commit_index, last_log_index)
        if ~index.le(append_leader_commit_index(m), ci) {
            ci := get_last_log_entry_of_node(n);
            if index.le(append_leader_commit_index(m), ci) {
                ci := append_leader_commit_index(m)
            };
            commit_index(n, I) := I = ci
        };

        # send reply (again, tuple, assume as assing)
        assume append_reply.source(r) = n;
        assume append_reply_new_log_index(r) = i;
        append_reply.pending(r, append.source(m)) := true
    }
}

action receive_append_reply = {
    # a leader receives a reply to AppendEntry. Note that we don't
    # include the leader term in the reply, which is a bit strange,
    # but I think it's still correct
    local l:node, current_term:term, m:append_reply_t, n:node, i:index{
        assume leader(l);
        assume current_term_of_node(l, current_term);
        m := append_reply.receive(l);

        # update match_index after a successful AppendEntry
        n := append_reply.source(m);
        i := append_reply_new_log_index(m); # the index of the successfully added entry
        #
        # The imperative code that manipulates match_index:
        #
        # mi := match_index(l, n);
        # if ~index.le(i, mi) {
        #     match_index(l, n) := i
        # }
        #
        # The code to opdate matches:
        #
        matches(l, n, I) := matches(l, n, I) | index.le(I, i)
    }
}

action commit = {
    # leader increases commit_index after it received a quorum of
    # receive_append_reply. In practice this would be checked for when
    # processing an AppendEntry response.
    #
    # If there exists i s.t. i > commit_index, a majority of
    # match_index[.] >= i, and log[i].term = current_term, set
    # commit_index = i
    #
    # To simplify things, we assume here we always increase the
    # commit_index by one. We can do the general increase when we have
    # if-then-else terms.
    #
    local l:node, current_term:term, ci:index, q:quorum, i:index, c:command {
        assume leader(l);
        assume current_term_of_node(l, current_term);
        assume commit_index(l, ci);

        i := index.get_succ(ci); # instead of assume ~le(i, ci);
        assume member(N, q) -> matches(l, N, i);
        assume log_term(l, i, current_term);

        # record quorum_of_commit for all indices I
        # s.t. commit_index(l) < I <= i.  After we have if-then-else
        # terms this would be easy, but for now we just make it easy
        # by assuming that i is the successor of commit_index(l),
        # i.e. we always increase the commit index by one.
        quorum_of_commit(i) := q;
        commit_index(l, I) := I = i;
        assume log_command(l, i, c);
        committed(i, current_term, c) := true
    }
}

export client_request
export send_append
export receive_append
export receive_append_reply
export commit

################################################################################
#
# Leader election safety property and inductive invariant
#
################################################################################

# Bogus conjecture to ensure that it is possible to elect a leader with three nodes and interesting quorums
#conjecture ~(leader(N1) & N1 ~= N2 & N1 ~= N3 & N2 ~= N3 & ~member(N1, Q1) & ~member(N2, Q2) & ~member(N3, Q3))

# Election safety invariant from the paper:
conjecture leader(N1) & leader(N2) & current_term_of_node(N1, T) & current_term_of_node(N2, T) -> N1 = N2

# election safety invariant adapted from Jame's cleaned up invariant:
conjecture ~(request_vote_reply.pending(R,N) & ~voted_for(request_vote_reply_term(R),request_vote_reply.source(R),N))
conjecture ~(current_term_of_node(L,T) & member(V,quorum_of_election(T)) & leader(L) & ~received_votes(T,L,V))
conjecture ~(received_votes(T,N,V) & ~voted_for(T,V,N))
conjecture ~(current_term_of_node(V, CT) & term.le(CT,T) & voted_for(T,V,N) & CT ~= T)


################################################################################
#
# Log replication safety property and inductive invariant
#
################################################################################

# Bogus conjecture to ensure it is possible to commit an entry.  With
# a non-fresh start, a trace of 2 actions is found in 20 seconds, with
# just one node that gets a request and then commits it.
# conjecture commit_index(N) = index.zero

# Bogus axioms and conjecture to ensure it is possible to commit an entry, with
# three nodes and majority quorums.  With a non-fresh start, and
# disabling of leader election commands, a trace of 5 actions is
# found in 2 minutes.
# individual n1:node
# individual n2:node
# individual n3:node
# individual q1:quorum
# individual q2:quorum
# individual q3:quorum
# axiom  n1 ~= n2 & n1 ~= n3 & n2 ~= n3
# axiom N = n1 | N = n2 | N = n3
# axiom  q1 ~= q2 & q1 ~= q3 & q2 ~= q3
# axiom Q = q1 | Q = q2 | Q = q3
# axiom (
#     ~member(n1, q1) &  member(n1, q2) &  member(n1, q3) &
#      member(n2, q1) & ~member(n2, q2) &  member(n2, q3) &
#      member(n3, q1) &  member(n3, q2) & ~member(n3, q3)
# )
# conjecture commit_index(N1, I) -> I = index.zero

# Log replication safety
#
# TODO: formalize a conjecture that just states the safety of
# committed entries, without the "log matching" property from the
# paper, which should be discovered in the search for inductive
# invariant.
#

# Safety: committed entries are never removed
#
# If you remove the quorum intersection axioms and start from a
# non-fresh initial state, ivy_bmc finds a trace of 6 actions in 7
# minutes.
conjecture ~removed_committed(N)

# Safety: nodes agree on the committed parts of their logs
conjecture commit_index(N1, CI1) & commit_index(N2, CI2) & index.le(I, CI1) & index.le(I, CI2) -> (
    (log_term(N1, I, T1) & log_term(N2, I, T2) -> T1 = T2) &
    (log_command(N1, I, C1) & log_command(N2, I, C2) -> C1 = C2)
)

# Log matching property from the paper
conjecture log_term(N1, I, T) & log_term(N2, I, T) & index.le(J, I) -> (
    (log_term(N1, J, T1) & log_term(N2, J, T2) -> T1 = T2) &
    (log_command(N1, J, C1) & log_command(N2, J, C2) -> C1 = C2)
)

# Log matching using biglog:
conjecture biglog(I, T, C1) & biglog(I, T, C2) -> C1 = C2

# Leader completeness property from the paper
conjecture commit_index(N1, CI1) & index.le(I, CI1) & log_term(N1, I, T1) & term.le(T1, T2) & leader(N2) & current_term_of_node(N2, T2) -> (
    (log_term(N1, I, TT1) & log_term(N2, I, TT2) -> TT1 = TT2) &
    (log_command(N1, I, C1) & log_command(N2, I, C2) -> C1 = C2)
)

# conjectures obtained interactively and manually:

# conjectures that I thought were true but turned out false (interesting test for BMC perfomence):
# conjecture ~(append.pending(A,N) & ~log_term(append.source(A),append_new_log_index(A),append_new_term(A)))
# conjecture ~(append.pending(A,N) & ~log_term(append.source(A),append_prev_log_index(A),append_prev_log_term(A)))
# conjecture ~(append.pending(A,N) & ~log_command(append.source(A),append_new_log_index(A),append_new_command(A)))

# another incorrect verions:
# conjecture append.pending(A,N) & log_term(append.source(A),append_new_log_index(A),T) -> term.le(append_new_term(A), T)
# conjecture append.pending(A,N) & log_term(append.source(A),append_prev_log_index(A),T) -> term.le(append_prev_log_term(A), T)

# attempt with biglog
conjecture append.pending(A,N) -> biglog(append_new_log_index(A), append_new_term(A), append_new_command(A))

# more conjectures
conjecture append.pending(A,N) & current_term_of_node(append.source(A),T) -> term.le(append_prev_log_term(A), T)
conjecture append.pending(A,N) & current_term_of_node(append.source(A),T) -> term.le(append_new_term(A), T)
conjecture  ~(current_term_of_node(N0,T0) & log_term(N0,I1,T1) & term.le(T0,T1) & T0 ~= T1)
conjecture ~(append.pending(A0,N1) & term.le(append_leader_term(A0),append_new_term(A0)) & append_leader_term(A0) ~= append_new_term(A0)) # rel. ind. + 3
# conjecture ~(log_term(N0,I0,T0) & log_term_was_ge(N0,I0,T1) & term.le(T0,T1) & T1 ~= T0)

# properties of the quorum of commit, similar to leader completeness
conjecture commit_index(N1, CI1) & index.le(I, CI1) & member(N2, quorum_of_commit(I)) -> (
    (log_term(N1, I, T1) & log_term(N2, I, T2) -> T1 = T2) &
    (log_command(N1, I, C1) & log_command(N2, I, C2) -> C1 = C2)
)

# properties of committed entries
conjecture committed(I, T1, C1) & committed(I, T2, C2) -> (T1=T2 & C1=C2)
conjecture committed(I, T, C) & member(N, quorum_of_commit(I)) -> (
    log_term(N, I, T) &
    log_command(N, I, C)
)

# committed entries and append messages agree
conjecture (
    append.pending(A,N) &
    committed(append_new_log_index(A), T, C) &
    term.le(T, append_leader_term(A))
) -> (append_new_term(A) = T & append_new_command(A) = C)
